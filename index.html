<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Filtre photo</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; padding: 16px; max-width: 820px; margin-inline: auto; }
    h1 { font-size: 20px; margin: 0 0 8px; }
    p { margin: 0 0 12px; opacity: .85; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 14px; padding: 12px; }
    canvas { width: min(420px, 100%); aspect-ratio: 1/1; border-radius: 12px; border: 1px solid rgba(127,127,127,.35); touch-action: none; background: rgba(127,127,127,.08); }
    .controls { display: grid; gap: 10px; min-width: 260px; }
    button, input[type="file"] { font: inherit; }
    button { padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(127,127,127,.35); background: transparent; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .zoom { display: grid; grid-template-columns: 36px 1fr 36px; gap: 8px; align-items: center; }
    input[type="range"] { width: 100%; }
    #outImg { width: min(420px, 100%); border-radius: 12px; border: 1px solid rgba(127,127,127,.35); display: none; }
    small { opacity: .75; }
  </style>
</head>
<body>
  <h1>Ajoutez votre photo</h1>
  <p>Glissez pour centrer, et utilisez le zoom si besoin. Puis générez et téléchargez.</p>

  <div class="row">
    <div class="card">
      <canvas id="canvas" width="1024" height="1024" aria-label="Aperçu"></canvas>
    </div>

    <div class="card controls">
      <input id="file" type="file" accept="image/*" />
      <div class="zoom">
        <button id="zoomOut" type="button" title="Zoom -">–</button>
        <input id="zoom" type="range" min="0.6" max="2.5" step="0.01" value="1" />
        <button id="zoomIn" type="button" title="Zoom +">+</button>
      </div>

      <button id="center" type="button" disabled>Recentrer</button>
      <button id="generate" type="button" disabled>Générer ma photo</button>
      <button id="download" type="button" disabled>Télécharger (PNG)</button>

      <small>Sur iPhone : après génération, appui long sur l’image puis “Ajouter aux Photos”.</small>
    </div>
  </div>

  <div style="height:12px"></div>
  <img id="outImg" alt="Image générée" />

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const fileInput = document.getElementById('file');
  const zoomRange = document.getElementById('zoom');
  const zoomOutBtn = document.getElementById('zoomOut');
  const zoomInBtn = document.getElementById('zoomIn');

  const centerBtn = document.getElementById('center');
  const genBtn = document.getElementById('generate');
  const dlBtn = document.getElementById('download');

  const outImg = document.getElementById('outImg');

  const overlay = new Image();
  overlay.src = 'cadre.png';

  let photo = null;

  let scale = 1;
  let offsetX = 0;
  let offsetY = 0;

  let lastX = 0;
  let lastY = 0;

  let pinch = { active: false, startDist: 0, startScale: 1, center: null };
  const active = new Map();

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function constrain() {
    if (!photo) return;
    const cw = canvas.width, ch = canvas.height;
    const w = photo.width * scale;
    const h = photo.height * scale;
    const minX = cw - w;
    const minY = ch - h;
    offsetX = clamp(offsetX, minX, 0);
    offsetY = clamp(offsetY, minY, 0);
  }

  function draw() {
    const cw = canvas.width, ch = canvas.height;
    ctx.clearRect(0, 0, cw, ch);

    ctx.fillStyle = 'rgba(127,127,127,.10)';
    ctx.fillRect(0, 0, cw, ch);

    if (photo) {
      ctx.drawImage(photo, offsetX, offsetY, photo.width * scale, photo.height * scale);
    } else {
      ctx.fillStyle = 'rgba(127,127,127,.55)';
      ctx.font = '28px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Choisis une photo', cw/2, ch/2);
    }

    if (overlay.complete) {
      ctx.drawImage(overlay, 0, 0, cw, ch);
    }
  }

  function applyUserZoom(userZoom, anchorX, anchorY) {
    if (!photo) return;
    const cw = canvas.width, ch = canvas.height;
    const base = Math.max(cw / photo.width, ch / photo.height);

    const prevScale = scale;
    scale = base * userZoom;

    const k = scale / prevScale;
    offsetX = anchorX - (anchorX - offsetX) * k;
    offsetY = anchorY - (anchorY - offsetY) * k;

    constrain();
  }

  function resetView() {
    if (!photo) return;

    const cw = canvas.width, ch = canvas.height;
    const base = Math.max(cw / photo.width, ch / photo.height);
    scale = base;

    const w = photo.width * scale;
    const h = photo.height * scale;
    offsetX = (cw - w) / 2;
    offsetY = (ch - h) / 2;

    const userZoom = parseFloat(zoomRange.value);
    applyUserZoom(userZoom, cw/2, ch/2);

    draw();
  }

  function enableUI(enabled) {
    centerBtn.disabled = !enabled;
    genBtn.disabled = !enabled;
    dlBtn.disabled = true;
  }

  function pointerPos(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;

    const img = new Image();
    img.decoding = 'async';
    img.src = URL.createObjectURL(f);
    await img.decode();

    photo = img;
    outImg.style.display = 'none';
    enableUI(true);
    resetView();
  });

  overlay.onload = draw;

  canvas.addEventListener('pointerdown', (ev) => {
    canvas.setPointerCapture(ev.pointerId);
    const p = pointerPos(ev);
    active.set(ev.pointerId, p);

    lastX = p.x;
    lastY = p.y;

    if (active.size === 2 && photo) {
      const pts = Array.from(active.values());
      pinch.active = true;
      pinch.startDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      pinch.startScale = scale;
      pinch.center = { x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2 };
    }
  });

  canvas.addEventListener('pointermove', (ev) => {
    if (!photo) return;
    if (!active.has(ev.pointerId)) return;

    const p = pointerPos(ev);
    active.set(ev.pointerId, p);

    if (active.size === 2 && pinch.active) {
      const pts = Array.from(active.values());
      const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      const factor = dist / pinch.startDist;

      const cw = canvas.width, ch = canvas.height;
      const base = Math.max(cw / photo.width, ch / photo.height);
      const targetScale = pinch.startScale * factor;
      const userZoom = clamp(targetScale / base, parseFloat(zoomRange.min), parseFloat(zoomRange.max));

      zoomRange.value = String(userZoom);
      applyUserZoom(userZoom, pinch.center.x, pinch.center.y);
      draw();
      return;
    }

    if (active.size === 1 && !pinch.active) {
      const dx = p.x - lastX;
      const dy = p.y - lastY;
      lastX = p.x;
      lastY = p.y;

      offsetX += dx;
      offsetY += dy;
      constrain();
      draw();
    }
  });

  function endPointer(ev) {
    active.delete(ev.pointerId);
    if (active.size < 2) pinch.active = false;
  }
  canvas.addEventListener('pointerup', endPointer);
  canvas.addEventListener('pointercancel', endPointer);
  canvas.addEventListener('pointerleave', endPointer);

  zoomRange.addEventListener('input', () => {
    if (!photo) return;
    applyUserZoom(parseFloat(zoomRange.value), canvas.width/2, canvas.height/2);
    draw();
  });

  zoomOutBtn.addEventListener('click', () => {
    zoomRange.value = String(Math.max(parseFloat(zoomRange.min), parseFloat(zoomRange.value) - 0.08));
    zoomRange.dispatchEvent(new Event('input'));
  });
  zoomInBtn.addEventListener('click', () => {
    zoomRange.value = String(Math.min(parseFloat(zoomRange.max), parseFloat(zoomRange.value) + 0.08));
    zoomRange.dispatchEvent(new Event('input'));
  });

  centerBtn.addEventListener('click', resetView);

  genBtn.addEventListener('click', () => {
    if (!photo) return;
    draw();
    const dataUrl = canvas.toDataURL('image/png');
    outImg.src = dataUrl;
    outImg.style.display = 'block';
    dlBtn.disabled = false;
    outImg.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  });

  dlBtn.addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = 'photo-filtre.png';
    a.href = canvas.toDataURL('image/png');
    a.click();
  });

  draw();
})();
</script>
</body>
</html>
